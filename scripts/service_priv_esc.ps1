# Author: Dustin Mallory
# Name: service_priv_esc
# Version: 1.0
# Description: This powershell script is designed with the intent to help identify weak permissions on misconfigured services
# which an attacker could use to escalate their privileges.
#
# CHANGE LOG
# Author           Date         Description
# Dustin Mallory | 02/02/2019 | Assists in identifying weak permssions on misconfigured services
#
$prevErrorActionPreference = $ErrorActionPreference
$ErrorActionPreference = "silentlycontinue"

function getStartmodeDescription {                                                                                 # Display service startmode information
    Param($startMode)
    return $(switch ($startMode) {
        "Boot" {"Device driver started by the operating system loader."}
        "System" {"Device driver started by the operating system initialization process."}
        "Auto" {"Service to be started automatically by the service control manager during system startup. Auto services are started even if a user does not log on."}
        "Manual" {"Service to be started by the Service Control Manager when a process calls the StartService method. These services do not start unless a user logs on and starts them."}
        "Disabled" {"Service that cannot be started until its StartMode is changed to either Auto or Manual."}
    })
}

$prevErrorActionPreference = $ErrorActionPreference
$ErrorActionPreference = "silentlycontinue"

Get-WmiObject win32_service |                                                                                       # Retrieves a listing of services installed on the system as win32_service
ForEach-Object {                                                                                                    # objects and iterates through each one
    $serviceAccount = $_.StartName
    $serviceName = $_.DisplayName
    $serviceDescription = $_.Description
    $startMode = $_.StartMode
    $servicePath = ( $_.PathName.Replace('"','').Substring(0, $_.PathName.Replace('"','').IndexOf(".exe"))+".exe"); # Retrieves the absolute path of the service binary
    $acl=Get-Acl $servicePath;                                                                                      # Gets the access control list associate with the executable
    if(!$acl.Path.EndsWith("svchost.exe")){                                                                         # Don't examine paths containing svchost binary (unlikely to have bad perms)
        foreach ($item in $acl.Access) {                                                                            # Iterate through each Item in the ACL access property
                if ( ($item.IdentityReference -match "NT AUTHORITY\\SYSTEM"   ) -or                                 # Ignore identify references are associated with high priv accounts
                    ($item.IdentityReference -match "NT SERVICE\\TrustedInstaller") -or
                    ($item.IdentityReference -match "NT AUTHORITY\\NETWORK"  ) -or
                    ($item.IdentityReference -match "BUILTIN\\Administrators") -or
                    ($item.IdentityReference -match "BUILTIN\\Power Users"   ) ) {
                } else {                                                                                            # else, check their filesystem rights allow us to tamper with the executable
                    if ($item.FileSystemRights.tostring() -match "Modify|Full|Change") {                            # If they do print write to STDOUT
                        Write "[!] $ServiceName : Potentially Elevated Service Permission(s)"
                        Write ("      -> "+$item.IdentityReference.value + " : "+$item.AccessControlType.tostring() + " : "+$item.FileSystemRights.tostring())
                        Write("")
                        Write('[!] Service is executed with "'+$serviceAccount+'" permissions')
                        Write("[!] Start Mode: $startMode :: $(getStartmodeDescription -startMode $startMode)")     # Display how the service is started
                        $acl | fl
                    }
            }
        }
    }
}
$ErrorActionPreference = $prevErrorActionPreference
